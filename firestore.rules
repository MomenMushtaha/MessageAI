rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // ============================================
    // HELPER FUNCTIONS
    // ============================================
    
    // Check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Check if the authenticated user matches the given userId
    function isUser(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    // Check if user is a participant in a conversation
    function isParticipant(conversationId) {
      return isAuthenticated() && 
             request.auth.uid in get(/databases/$(database)/documents/conversations/$(conversationId)).data.participantIds;
    }
    
    // Check if user is an admin of a group conversation
    function isAdmin(conversationId) {
      let conversation = get(/databases/$(database)/documents/conversations/$(conversationId)).data;
      return isAuthenticated() && 
             conversation.type == 'group' &&
             request.auth.uid in conversation.get('adminIds', []);
    }
    
    // Check if message is sent by the authenticated user
    function isMessageSender(messageData) {
      return isAuthenticated() && request.auth.uid == messageData.senderId;
    }
    
    // Check if message can be edited (within 15 minutes, by sender)
    function canEditMessage(messageData) {
      return isMessageSender(messageData) &&
             (request.time.toMillis() - messageData.createdAt.toMillis()) < 900000; // 15 minutes
    }
    
    // Check if message can be deleted for everyone (only by sender)
    function canDeleteForEveryone(messageData) {
      return isMessageSender(messageData);
    }
    
    // Validate message data
    function isValidMessage() {
      let message = request.resource.data;
      return message.senderId is string &&
             message.text is string &&
             message.text.size() > 0 &&
             message.text.size() <= 4096 &&
             message.createdAt is timestamp &&
             message.status is string &&
             message.conversationId is string;
    }
    
    // ============================================
    // USERS COLLECTION
    // ============================================
    
    match /users/{userId} {
      // Anyone can read user profiles (for displaying names, avatars)
      // But limit what fields are exposed
      allow read: if isAuthenticated();
      
      // Users can only create/update their own profile
      allow create: if isUser(userId) &&
                      request.resource.data.id == userId &&
                      request.resource.data.email is string &&
                      request.resource.data.displayName is string;
      
      allow update: if isUser(userId) &&
                      // Prevent changing immutable fields
                      request.resource.data.id == resource.data.id &&
                      request.resource.data.email == resource.data.email;
      
      // Users cannot delete their own profile (prevent data loss)
      allow delete: if false;
      
      // User presence sub-collection
      match /presence/{document=**} {
        allow read: if isAuthenticated();
        allow write: if isUser(userId);
      }
    }
    
    // ============================================
    // CONVERSATIONS COLLECTION
    // ============================================
    
    match /conversations/{conversationId} {
      // Read: Only participants can read conversation metadata
      allow read: if isParticipant(conversationId);
      
      // Create: Anyone can create a conversation if they include themselves as a participant
      allow create: if isAuthenticated() &&
                      request.auth.uid in request.resource.data.participantIds &&
                      request.resource.data.participantIds is list &&
                      request.resource.data.participantIds.size() >= 2 &&
                      request.resource.data.type in ['direct', 'group'] &&
                      request.resource.data.createdAt is timestamp &&
                      // Group chats must have a name
                      (request.resource.data.type == 'direct' || 
                       (request.resource.data.type == 'group' && request.resource.data.groupName is string));
      
      // Update: Only participants can update, with restrictions
      allow update: if isParticipant(conversationId) &&
                      // Can't change conversation type
                      request.resource.data.type == resource.data.type &&
                      // Can't remove yourself from participants (use leave instead)
                      request.auth.uid in request.resource.data.participantIds &&
                      // For groups: only admins can modify certain fields
                      (resource.data.type == 'direct' || 
                       (isAdmin(conversationId) || 
                        // Non-admins can only update lastMessage fields (from sending messages)
                        (request.resource.data.participantIds == resource.data.participantIds &&
                         request.resource.data.get('adminIds', []) == resource.data.get('adminIds', []) &&
                         request.resource.data.get('groupName', '') == resource.data.get('groupName', ''))));
      
      // Delete: Only for group admins OR direct chat participants
      allow delete: if resource.data.type == 'group' ? isAdmin(conversationId) : isParticipant(conversationId);
      
      // ============================================
      // MESSAGES SUB-COLLECTION
      // ============================================
      
      match /messages/{messageId} {
        // Read: Only conversation participants can read messages
        allow read: if isParticipant(conversationId);
        
        // Create: Only participants can send messages, with validation
        allow create: if isParticipant(conversationId) &&
                        isValidMessage() &&
                        request.resource.data.senderId == request.auth.uid &&
                        request.resource.data.conversationId == conversationId;
        
        // Update: Multiple scenarios allowed
        allow update: if isParticipant(conversationId) &&
                        (
                          // Scenario 1: Sender editing their own message (within 15 min)
                          (canEditMessage(resource.data) &&
                           request.resource.data.text != resource.data.text &&
                           request.resource.data.senderId == resource.data.senderId) ||
                          
                          // Scenario 2: Sender deleting for everyone
                          (canDeleteForEveryone(resource.data) &&
                           request.resource.data.keys().hasAny(['deletedForEveryone', 'deletedBy'])) ||
                          
                          // Scenario 3: Any participant marking as deleted for themselves
                          (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['deletedBy']) &&
                           request.auth.uid in request.resource.data.deletedBy) ||
                          
                          // Scenario 4: Recipients marking as delivered
                          (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['deliveredTo']) &&
                           request.auth.uid in request.resource.data.deliveredTo &&
                           resource.data.senderId != request.auth.uid) ||
                          
                          // Scenario 5: Recipients marking as read
                          (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['readBy', 'deliveredTo']) &&
                           request.auth.uid in request.resource.data.readBy &&
                           resource.data.senderId != request.auth.uid) ||
                          
                          // Scenario 6: Adding/removing reactions
                          (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['reactions']))
                        );
        
        // Delete: Only sender can delete their message completely (rare, usually just mark as deleted)
        allow delete: if isMessageSender(resource.data);
      }
      
      // ============================================
      // TYPING STATUS SUB-COLLECTION
      // ============================================
      
      match /typing/{userId} {
        // Read: All participants can see who's typing
        allow read: if isParticipant(conversationId);
        
        // Write: Users can only update their own typing status
        allow write: if isUser(userId) && isParticipant(conversationId);
      }
      
      // ============================================
      // UNREAD COUNTS SUB-COLLECTION
      // ============================================
      
      match /unreadCounts/{userId} {
        // Read: Users can only read their own unread count
        allow read: if isUser(userId);
        
        // Write: System only (Cloud Functions)
        allow write: if false;
      }
    }
    
    // ============================================
    // PUSH NOTIFICATION TOKENS
    // ============================================
    
    match /fcmTokens/{userId} {
      // Users can only read/write their own tokens
      allow read, write: if isUser(userId);
    }
    
    // ============================================
    // ANALYTICS & METRICS (Optional)
    // ============================================
    
    match /analytics/{document=**} {
      // Read-only for authenticated users
      allow read: if isAuthenticated();
      
      // Write: System only (Cloud Functions)
      allow write: if false;
    }
    
    // ============================================
    // BLOCK ALL OTHER COLLECTIONS
    // ============================================
    
    // Deny access to any other collections not explicitly defined
    match /{document=**} {
      allow read, write: if false;
    }
  }
}

