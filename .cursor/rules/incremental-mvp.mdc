---
alwaysApply: true
---

# MessageAI WhatsApp Clone - Incremental MVP Plan

## Core Principle
Each step below produces a **buildable, runnable, and testable** app in Xcode. No step should break the build. Test on simulator after completing each step before moving to the next.

---

## âœ… Step 0: Foundation (COMPLETED)
**Status:** âœ… Done
**What exists:**
- Firebase SDK integrated (Auth, Firestore, Messaging, Analytics)
- Firebase initialized with offline persistence
- GoogleService-Info.plist configured
- iOS deployment target: iOS 17.0
- SwiftData setup with Message model

**Verification:** âœ… App builds successfully

---

## ğŸ“± Step 1: Basic UI Structure & Navigation
**Goal:** Create empty screens with navigation flow

**Implementation:**
1. Create `Models/User.swift` - basic user model (id, displayName, email, avatarURL)
2. Create `Models/Conversation.swift` - conversation model (id, title, participants, lastMessage, timestamp)
3. Create `Views/Auth/LoginView.swift` - email/password input fields + login button (no logic yet)
4. Create `Views/Auth/SignUpView.swift` - name, email, password fields + signup button (no logic yet)
5. Create `Views/ChatList/ChatListView.swift` - empty list with navigation bar + "New Chat" button
6. Create `Views/Conversation/ConversationDetailView.swift` - empty conversation with message input field
7. Update `MainAppView.swift` - show LoginView vs ChatListView based on mock auth state
8. Add navigation: ChatList â†’ ConversationDetail

**Testable:** 
- âœ… Navigate between all screens
- âœ… UI renders correctly
- âœ… No crashes

**Expected Output:** Clickable prototype with all main screens, no backend functionality

---

## ğŸ” Step 2: Firebase Authentication
**Goal:** Real user signup, login, logout with Firebase

**Implementation:**
1. Create `Services/AuthService.swift`
   - `signUp(email:password:displayName:) async throws`
   - `login(email:password:) async throws`
   - `logout() throws`
   - `@Published var currentUser: User?`
   - Listen to `Auth.auth().addStateDidChangeListener`
2. Create Firestore `users/{userId}` collection on signup
   - Store: userId, email, displayName, createdAt
3. Update LoginView - wire up AuthService.login()
4. Update SignUpView - wire up AuthService.signUp()
5. Update MainAppView - use AuthService.currentUser to show Login vs ChatList
6. Add "Logout" button in ChatListView navigation bar

**Testable:**
- âœ… Create account with email/password
- âœ… Login with created account
- âœ… Logout returns to login screen
- âœ… User document created in Firestore
- âœ… State persists across app restarts (Firebase handles this)

**Expected Output:** Working authentication, users stored in Firestore

---

## ğŸ’¬ Step 3: One-to-One Messaging (Real-time)
**Goal:** Send and receive text messages between two users in real-time

**Implementation:**
1. Create `Services/ChatService.swift`
   - `sendMessage(conversationId:text:) async throws` - writes to Firestore
   - `observeMessages(conversationId:) -> AsyncStream<[Message]>` - Firestore listener
   - Firestore structure:
     ```
     conversations/{conversationId}
       - participantIds: [userId1, userId2]
       - lastMessageText: String
       - lastMessageAt: Timestamp
       - createdAt: Timestamp
     
     conversations/{conversationId}/messages/{messageId}
       - senderId: String
       - text: String
       - createdAt: Timestamp
       - status: String (sending, sent, delivered, read)
     ```
2. Create `Views/ChatList/NewChatView.swift`
   - List all users from Firestore `users` collection
   - Tap user â†’ create/find conversation â†’ navigate to ConversationDetailView
   - Create conversation with deterministic ID: `sorted([userId1, userId2]).joined(separator: "_")`
3. Update `ChatListView.swift`
   - Firestore listener for conversations where currentUser.id in participantIds
   - Display conversation rows (avatar, name, last message, timestamp)
   - Tap row â†’ navigate to ConversationDetailView
4. Update `ConversationDetailView.swift`
   - Firestore listener for messages subcollection
   - Display message bubbles (sender name, text, timestamp)
   - Message input field + send button
   - Scroll to bottom on new messages
5. Create `Components/MessageBubble.swift` - reusable message bubble (left/right aligned)

**Testable:**
- âœ… Create two accounts (User A, User B)
- âœ… User A starts chat with User B
- âœ… User A sends message â†’ User B sees it instantly
- âœ… User B replies â†’ User A sees it instantly
- âœ… Messages persist in Firestore
- âœ… Conversation appears in both users' chat lists

**Expected Output:** Fully functional 1-on-1 real-time messaging

---

## ğŸ“¦ Step 4: SwiftData Local Persistence & Offline Support
**Goal:** Messages load instantly from local cache, work offline

**Implementation:**
1. Create `Models/LocalMessage.swift` (SwiftData)
   - Properties: id, conversationId, senderId, text, createdAt, status, isSynced
   - Add to ModelContainer schema
2. Create `Models/LocalConversation.swift` (SwiftData)
   - Properties: id, title, participantIds, lastMessageText, lastMessageAt, isSynced
   - Add to ModelContainer schema
3. Update `ChatService.swift`
   - `sendMessage()`: Write to SwiftData immediately (status: sending), then Firestore
   - On Firestore success: update status to "sent"
   - On Firestore failure: status stays "sending", retry later
   - `observeMessages()`: Load from SwiftData first (instant), then merge Firestore updates
4. Add sync logic:
   - On app launch: upload pending messages (status: sending)
   - Firestore listener updates â†’ save to SwiftData
5. Add network status banner:
   - Use `NWPathMonitor` to detect connectivity
   - Show "No Connection" banner when offline

**Testable:**
- âœ… Send message while online â†’ appears instantly
- âœ… Enable airplane mode â†’ send message â†’ shows "sending" status
- âœ… Disable airplane mode â†’ message syncs to Firestore
- âœ… Force quit app â†’ relaunch â†’ messages load instantly from SwiftData
- âœ… Close and reopen conversation â†’ messages still there

**Expected Output:** Offline-first messaging with local persistence

---

## ğŸ‘¥ Step 5: Group Chats
**Goal:** Support multi-user group conversations

**Implementation:**
1. Update Firestore `conversations` collection:
   - Add `type: String` (direct/group)
   - Add `groupName: String?`
   - Add `groupAvatarURL: String?`
   - participantIds becomes array of 2+ users for groups
2. Create `Views/ChatList/NewGroupView.swift`
   - Multi-select user list
   - Group name input field
   - "Create Group" button
   - Create conversation with type: "group", random conversationId
3. Update `ChatListView.swift`
   - Show group icon/avatar for group chats
   - Display group name instead of participant name
4. Update `ConversationDetailView.swift`
   - Show group name in navigation bar
   - Display sender name above each message (for groups)
   - Show participant list (tap nav bar)
5. Update `ChatService.sendMessage()`
   - Handle group conversations (no changes needed if done right)

**Testable:**
- âœ… Create group with 3+ users
- âœ… All participants see the group in chat list
- âœ… Send message in group â†’ all participants receive it
- âœ… Each message shows sender name
- âœ… View group participant list

**Expected Output:** Working group chat functionality

---

## âœ“ Step 6: Message Status & Read Receipts
**Goal:** Show message delivery status (sent, delivered, read) and read receipts

**Implementation:**
1. Update Firestore `messages` document:
   - Add `deliveredTo: [String]` - array of userIds who received message
   - Add `readBy: [String]` - array of userIds who read message
2. Update `ChatService.swift`
   - When opening conversation: mark all messages as read
     - Update `readBy` array in Firestore for unread messages
   - When receiving message: mark as delivered
     - Update `deliveredTo` array in Firestore
3. Update `ConversationDetailView.swift`
   - On appear: mark messages as read
   - On receive new message: mark as delivered
4. Create `Components/MessageStatusIcon.swift`
   - Single checkmark: sent (message exists in Firestore)
   - Double checkmark: delivered (in deliveredTo for all recipients)
   - Blue double checkmark: read (in readBy for all recipients)
5. Update `MessageBubble.swift` - show status icon for sent messages
6. Update `LocalMessage` model - add deliveredTo, readBy fields

**Testable:**
- âœ… Send message â†’ shows single checkmark
- âœ… Recipient opens app â†’ sender sees double checkmark
- âœ… Recipient opens conversation â†’ sender sees blue double checkmark
- âœ… Group messages show delivered when all participants received

**Expected Output:** WhatsApp-style message status indicators

---

## ğŸŸ¢ Step 7: User Presence (Online/Offline Status)
**Goal:** Show when users are online/offline with "last seen" timestamp

**Implementation:**
1. Create `Services/PresenceService.swift`
   - Update Firestore `users/{userId}/presence`:
     - `isOnline: Bool`
     - `lastSeen: Timestamp`
   - On app foreground: set isOnline = true
   - On app background: set isOnline = false, update lastSeen
   - Heartbeat every 30 seconds while active
2. Update `User.swift` model - add isOnline, lastSeen properties
3. Update `ConversationDetailView.swift`
   - Show "Online" or "Last seen [time]" in navigation subtitle
   - For groups: show "X participants"
4. Update `ChatListView.swift`
   - Show green dot on avatar if user isOnline
5. Initialize PresenceService in app init

**Testable:**
- âœ… User A online â†’ User B sees "Online" status
- âœ… User A backgrounds app â†’ User B sees "Last seen [time]"
- âœ… User A force quits â†’ User B sees last seen timestamp
- âœ… Green dot appears on online users in chat list

**Expected Output:** Real-time presence indicators

---

## ğŸ”” Step 8: In-App Foreground Notifications (No APNs)
**Goal:** Show notification banner when receiving message while app is open

**Implementation:**
1. Create `Services/NotificationService.swift`
   - `showInAppNotification(title:body:avatar:)` - displays banner
   - Use `UNUserNotificationCenter` for local notifications
   - Request notification permission on first launch
2. Create `Components/InAppNotificationBanner.swift`
   - Custom SwiftUI overlay banner
   - Shows sender avatar, name, message preview
   - Tap to open conversation
   - Auto-dismiss after 4 seconds
   - Slide-in animation from top
3. Update `ChatService.swift`
   - When receiving new message via Firestore listener:
     - If conversation is NOT currently open â†’ show notification
     - If app in foreground and conversation â‰  current â†’ show banner
4. Update `MainAppView.swift`
   - Add `.overlay()` for notification banner at top
   - Manage banner state with `@State var currentNotification`

**Key:** This uses **local notifications** triggered by Firestore listeners, NO network push needed, NO APNs certificate required, works on simulator.

**Testable:**
- âœ… User A sends message to User B
- âœ… User B has app open but viewing different conversation â†’ sees banner
- âœ… User B taps banner â†’ navigates to conversation with User A
- âœ… User B is viewing conversation with User A â†’ no banner (already there)
- âœ… Works on simulator without developer account

**Expected Output:** In-app notification banners for incoming messages

---

## ğŸ¨ Step 9: UI Polish & Animations
**Goal:** Make UI feel polished and smooth

**Implementation:**
1. Add smooth animations:
   - Message send animation (slide up + fade in)
   - Typing indicator (animated dots)
   - Pull-to-refresh conversations
   - Swipe gestures on conversation rows
2. Improve message bubbles:
   - Rounded corners (more like WhatsApp)
   - Tails on bubbles
   - Message grouping (same sender consecutive messages)
   - Timestamp only on last message in group
3. Add loading states:
   - Skeleton screens while loading conversations
   - Spinner while sending message
   - "Connecting..." indicator when offline
4. Improve conversation view:
   - Sticky date headers
   - Scroll-to-bottom button (when scrolled up)
   - Auto-scroll on new message
5. Add avatars everywhere:
   - User avatars in chat list
   - Group avatars (composite or emoji)
   - Message sender avatars in groups
6. Improve chat list:
   - Unread message count badges
   - Bold text for unread conversations
   - Swipe-to-delete conversation

**Testable:**
- âœ… Animations are smooth (60fps)
- âœ… UI matches WhatsApp aesthetics
- âœ… Loading states prevent confusion
- âœ… App feels responsive

**Expected Output:** Polished, professional-looking app

---

## ğŸ§ª Step 10: Testing & Edge Cases
**Goal:** Handle edge cases and ensure stability

**Implementation:**
1. Add error handling:
   - Show alert on auth failure (wrong password, etc.)
   - Handle network errors gracefully
   - Retry failed messages with exponential backoff
2. Add input validation:
   - Email format validation
   - Password strength requirements
   - Empty message prevention
   - Character limits on messages
3. Add edge case handling:
   - Empty states (no conversations, no messages)
   - Long messages (text wrapping)
   - Rapid message sending (prevent duplicates)
   - Large chat lists (pagination/lazy loading)
4. Add loading states:
   - Skeleton loaders for chat list
   - Progress indicators for auth
5. Performance optimization:
   - Limit initial message load (last 50 messages)
   - Lazy load older messages on scroll up
   - Debounce Firestore listeners
6. Memory management:
   - Cancel listeners on view disappear
   - Clear caches appropriately

**Testable:**
- âœ… Send 100 messages rapidly â†’ no duplicates or crashes
- âœ… Poor network â†’ shows proper error messages
- âœ… Invalid email â†’ shows validation error
- âœ… Empty chat list â†’ shows helpful empty state
- âœ… Long conversation (500+ messages) â†’ scrolls smoothly

**Expected Output:** Stable, production-ready app

---

## ğŸš€ Step 11: Optional Enhancements (Post-MVP)
**Not required for MVP, but nice to have:**

1. **Media Attachments**
   - Image picker + Firebase Storage upload
   - Image thumbnails in chat
   - Full-screen image viewer

2. **Search**
   - Search messages within conversation
   - Search conversations by name

3. **Message Reactions**
   - Emoji reactions on messages
   - Show reaction counts

4. **Voice Messages**
   - Record audio messages
   - Playback with waveform

5. **Push Notifications (Background)**
   - Requires Apple Developer account
   - APNs setup + Firebase Cloud Functions
   - Background notification delivery

---

## ğŸ“‹ Implementation Checklist

After each step:
- [ ] Build succeeds (âŒ˜+B)
- [ ] No compiler errors or warnings
- [ ] Run on simulator - no crashes
- [ ] Test new functionality manually
- [ ] Git commit with descriptive message
- [ ] Test existing features still work (regression test)

---

## ğŸ—ï¸ Architecture Guidelines

**Service Layer:**
- AuthService (singleton, manages current user)
- ChatService (handles Firestore messaging)
- PresenceService (manages online status)
- NotificationService (in-app banners)

**Data Layer:**
- Firestore (source of truth, real-time sync)
- SwiftData (local cache, offline support)
- Sync strategy: Firestore listeners â†’ SwiftData â†’ UI

**UI Layer:**
- SwiftUI views (reactive to @Published properties)
- ViewModels where needed (complex state)
- Reusable components (MessageBubble, UserRow, etc.)

**Navigation:**
- NavigationStack (iOS 17+)
- Programmatic navigation for deep links
- Sheet/fullScreenCover for modals

---

## ğŸ¯ Success Criteria

An MVP is complete when:
1. âœ… Two users can create accounts
2. âœ… Users can send/receive real-time messages
3. âœ… Messages persist offline and sync when online
4. âœ… Group chats work with 3+ users
5. âœ… Read receipts and online status work
6. âœ… In-app notifications show for new messages
7. âœ… UI is polished and bug-free
8. âœ… App is stable under normal use

**Time Estimate:** 
- Steps 1-3: ~2-3 hours
- Steps 4-5: ~2-3 hours
- Steps 6-7: ~2 hours
- Steps 8-9: ~2-3 hours
- Step 10: ~1-2 hours
- **Total: ~10-15 hours of focused development**

---

## ğŸ”§ Development Tips

1. **Test as you go** - Don't skip testing steps
2. **Commit often** - Commit after each working feature
3. **Use print statements** - Debug Firestore listeners
4. **Firestore Console** - Monitor database in real-time
5. **Simulator side-by-side** - Test with 2 simulators for messaging
6. **Network Link Conditioner** - Test offline scenarios
7. **Xcode Previews** - Use for UI components
8. **Breakpoints** - Debug async code carefully

---

## ğŸ“± Testing Strategy

**Multi-device testing:**
1. Run 2 simulators side-by-side (User A & User B)
2. Create account on each
3. Test messaging flow
4. Test offline on one device

**Scenarios to test:**
- âœ… Happy path: signup â†’ send message â†’ receive message
- âœ… Offline send â†’ reconnect â†’ sync
- âœ… Force quit â†’ relaunch â†’ messages persist
- âœ… Group chat with 3 people
- âœ… Rapid message sending (20+ messages)
- âœ… Long message text (500+ characters)
- âœ… Empty states (new user, no conversations)

**Performance benchmarks:**
- Message send latency: <500ms on wifi
- UI rendering: 60fps scrolling
- Cold start: <2 seconds to chat list
- Message sync: <1 second after reconnect
